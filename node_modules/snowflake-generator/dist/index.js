"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Generator = void 0;
const cached64BitZeros = '0000000000000000000000000000000000000000000000000000000000000000';
class Generator {
    /**
     * The main class used for generating snowflakes.
     * @param {Date|number} [epoch] - The epoch timestamp (in milliseconds) to generate from
     * @param {number} [shardID] - Useful when running multiple generators at the same time to prevent duplicates.
     */
    constructor(epoch, shardID) {
        this.EPOCH = epoch ? new Date(epoch).valueOf() : Date.UTC(2000, 0, 1).valueOf();
        this.SHARD_ID = shardID || 1;
        this.INCREMENT = 0;
    }
    /**
     * Generates a single snowflake.
     * @param {number} timestamp - Timestamp to generate from
     * @returns {bigint}
     * @private
     */
    static _generate(generator, timestamp) {
        const i = generator.INCREMENT++ % 1024;
        // tslint:disable:no-bitwise
        let result = (BigInt(timestamp) - BigInt(generator.EPOCH)) << 23n;
        result = result | (BigInt(generator.SHARD_ID) << 10n);
        result = result | BigInt(i);
        // tslint:enable:no-bitwise
        return result;
    }
    /**
     * Generates snowflakes.
     * @param {number} [amount = 1] - Amount of snowflakes to generate, recommended not to go above `1024` or duplicates will arise.
     * @param {Date|number} [timestamp = Date.now] - Timestamp to generate from
     * @returns {bigint|bigint[]}
     */
    generate(amount = 1, timestamp = Date.now()) {
        if (timestamp instanceof Date)
            timestamp = timestamp.valueOf();
        else
            timestamp = new Date(timestamp).valueOf();
        if (amount === 1)
            return Generator._generate(this, timestamp);
        else {
            const results = [];
            for (let i = 0; i < amount; i++) {
                results.push(Generator._generate(this, timestamp));
            }
            return results;
        }
    }
    /**
     * Deconstruct a snowflake to its values.
     * @param {SnowflakeResolvable} snowflake - Snowflake to deconstruct
     * @returns {DeconstructedSnowflake}
     * @private
     */
    static _deconstruct(generator, snowflake) {
        const binary = Generator.binary(snowflake);
        return {
            snowflake: BigInt(snowflake),
            timestamp: Generator.extractBits(snowflake, 23n, 64n) + BigInt(generator.EPOCH),
            shard_id: Generator.extractBits(snowflake, 10n, 13n),
            increment: Generator.extractBits(snowflake, 0n, 10n),
            binary,
        };
    }
    /**
     * Deconstruct a snowflake to its values using the `Generator.epoch`.
     * @param {SnowflakeResolvable|SnowflakeResolvable[]} snowflake - Snowflake(s) to deconstruct
     * @returns {DeconstructedSnowflake|DeconstructedSnowflake[]}
     */
    deconstruct(snowflake) {
        // @ts-ignore
        if (snowflake instanceof Array)
            return snowflake.map((s) => this.deconstruct(s));
        return Generator._deconstruct(this, snowflake);
    }
    /**
     * Extract bits and their values from a snowflake.
     * @param {SnowflakeResolvable} snowflake - Snowflake to extract from
     * @param {number|bigint} shift - Number of bits to shift before extracting
     * @param {number|bigint} length - Number of bits to extract before stopping
     * @returns {bigint}
     */
    static extractBits(snowflake, shift, length) {
        const shiftN = BigInt(shift);
        // tslint:disable:no-bitwise
        const bitmask = ((1n << BigInt(length)) - 1n) << shiftN;
        return (BigInt(snowflake) & bitmask) >> shiftN;
        // tslint:enable:no-bitwise
    }
    /**
     * Transform a snowflake into its 64Bit binary string.
     * @param {SnowflakeResolvable} snowflake - Snowflake to transform
     * @returns {string}
     * @private
     */
    static binary(snowflake) {
        const binValue = BigInt(snowflake).toString(2);
        return binValue.length < 64 ? cached64BitZeros.substring(0, 64 - binValue.length) + binValue : binValue;
    }
}
exports.Generator = Generator;
//# sourceMappingURL=index.js.map